package entityClasses;

/**
 * <p><strong>Title:</strong> Post Class - Student Discussion Post Entity</p>
 * 
 * <p><strong>Description:</strong> Entity class representing a discussion post in the student
 * discussion system. This class implements the data structure and CRUD (Create, Read, Update, 
 * Delete) operations needed to support collaborative student discussions similar to Ed Discussion 
 * or Piazza.</p>
 * 
 * <p><strong>Supported User Stories (Student):</strong></p>
 * <ul>
 * <li><strong>US-01 (Create Posts):</strong> Students can create new discussion posts to ask 
 *     questions or share knowledge. This class provides the data structure (attributes: id, 
 *     author, content, authorRole) and is used by Database.createPost() to persist posts to 
 *     the H2 database.</li>
 * 
 * <li><strong>US-02 (Edit Posts):</strong> Students can edit their own posts to fix typos or 
 *     clarify content. The 'author' attribute enables ownership verification before allowing 
 *     edits via Database.updatePost(). The system prevents users from editing others' posts.</li>
 * 
 * <li><strong>US-03 (Delete Posts):</strong> Students can delete their own posts if posted in 
 *     error. The 'author' attribute enables ownership verification before deletion via 
 *     Database.deletePost(). The system prevents users from deleting others' posts.</li>
 * 
 * <li><strong>US-04 (View Posts):</strong> Students can view all posts from classmates. This 
 *     class is instantiated by Database.getAllPosts() and displayed in the GUI via 
 *     ModelPosts.formatPostForDisplay() which shows: "id: X author: Name [Role] content: Text"</li>
 * 
 * <li><strong>US-05 (Reply to Posts):</strong> Students can reply to posts to continue 
 *     discussions. The 'id' attribute serves as a foreign key in the Reply table, linking 
 *     replies to their parent post.</li>
 * </ul>
 * 
 * <p><strong>Design Rationale:</strong></p>
 * <p>This class follows the <strong>Entity/POJO (Plain Old Java Object)</strong> pattern, 
 * separating data structure from business logic. It uses <strong>encapsulation</strong> 
 * (private fields with public accessors) to protect data integrity and enable validation 
 * in future versions. The design follows the MVC architecture where:</p>
 * <ul>
 * <li><strong>Model (This Class + Database.java):</strong> Handles data and persistence</li>
 * <li><strong>View (ViewPosts.java):</strong> Displays data to users</li>
 * <li><strong>Controller (ControllerPosts.java):</strong> Coordinates between Model and View</li>
 * </ul>
 * 
 * <p><strong>Future Extensibility (TP3 - Staff User Stories):</strong></p>
 * <p>The 'authorRole' attribute was included to support future instructor analytics features:</p>
 * <ul>
 * <li><strong>Filter by Role:</strong> Instructors can filter posts by student role (Role1, Role2) 
 *     to assess group-specific participation and engagement patterns.</li>
 * <li><strong>Participation Reports:</strong> Analyze which roles are most/least active in 
 *     discussions, helping identify students who may need additional support.</li>
 * <li><strong>Role-Based Assessment:</strong> Compare discussion quality and quantity across 
 *     different student groups for grading purposes.</li>
 * <li><strong>Visual Identification:</strong> Display role badges ([Admin], [Role1], [Role2]) 
 *     in the UI so students and instructors can quickly identify the context of posts.</li>
 * </ul>
 * 
 * <p><strong>Database Schema:</strong></p>
 * <pre>
 * CREATE TABLE Post (
 *     id INT AUTO_INCREMENT PRIMARY KEY,
 *     author VARCHAR(255) NOT NULL,
 *     content VARCHAR(500) NOT NULL,
 *     authorRole VARCHAR(10)
 * );
 * 
 * Foreign Key Relationships:
 * - Reply.postId references Post.id (one-to-many relationship)
 * - User.userName referenced by Post.author (enforces referential integrity)
 * </pre>
 * 
 * <p><strong>Copyright:</strong> Team 25 © 2025</p>
 * 
 * @author Emmanuel Zelaya-Armenta
 * @author Elhan Elias
 * @author Mishal Riyas
 * @author Maheer Naveen
 * @author Ananya Sharma
 * @author Hossain Ahmed
 * @version 2.00 2025-10-27 Added authorRole tracking and enhanced documentation for TP2
 * @version 1.00 2025-10-13 Initial implementation for TP1
 * 
 * @see Reply
 * @see database.Database
 * @see guiPosts.ControllerPosts
 * @see guiPosts.ModelPosts
 * @see guiPosts.ViewPosts
 */
public class Post {
    
    // ==================== ATTRIBUTES ====================
    
    /**
     * Unique identifier for this post. Auto-generated by database on creation.
     * 
     * <p><strong>Source:</strong> H2 Database AUTO_INCREMENT PRIMARY KEY</p>
     * 
     * <p><strong>Data Type Rationale:</strong> Integer chosen for efficient indexing and 
     * foreign key references. Positive integers only (1, 2, 3...). Auto-increment ensures 
     * uniqueness without manual management.</p>
     * 
     * <p><strong>Rationale for Existence (User Story Mapping):</strong></p>
     * <ul>
     * <li><strong>US-02 (Edit Posts):</strong> Required to identify which specific post to 
     *     modify. When a user selects a post in the ListView and clicks "Edit Post", 
     *     ControllerPosts.performEditPost() extracts this ID using ModelPosts.getID() to 
     *     query the correct post from the database.</li>
     * 
     * <li><strong>US-03 (Delete Posts):</strong> Required to identify which post to remove. 
     *     ControllerPosts.performDeletePost() uses this ID to call 
     *     Database.deletePost(postID).</li>
     * 
     * <li><strong>US-05 (Replies):</strong> Foreign key in Reply table links to this ID, 
     *     establishing parent-child relationships. Reply.postId references Post.id to 
     *     retrieve all replies for a given post.</li>
     * 
     * <li><strong>GUI Selection:</strong> ListView displays posts as formatted strings. When 
     *     user clicks a post, ModelPosts.getID() parses this ID from the display string to 
     *     perform subsequent operations.</li>
     * </ul>
     * 
     * <p><strong>Data Flow Example:</strong></p>
     * <pre>
     * 1. Database.createPost() → INSERT INTO Post → generates ID via AUTO_INCREMENT
     * 2. ResultSet.getGeneratedKeys() → retrieves new ID
     * 3. Post object created with this ID
     * 4. ModelPosts.formatPostForDisplay() → includes ID in display: "id: 5 author: john..."
     * 5. User selects post → ModelPosts.getID() parses ID from string
     * 6. ID passed to Database.updatePost() or Database.deletePost()
     * </pre>
     * 
     * <p><strong>Immutability:</strong> This field should NEVER change after creation. The ID 
     * is the permanent identity of the post. Changing IDs would break foreign key relationships 
     * and cause data integrity issues.</p>
     */
    private int id;
    
    /**
     * Username of the student who created this post.
     * 
     * <p><strong>Source:</strong> User.getUserName() from the currently logged-in user at 
     * post creation time. Retrieved via ViewPosts.theUser.getUserName() in 
     * ControllerPosts.performSubmitPost().</p>
     * 
     * <p><strong>Data Type Rationale:</strong> String to match User.userName. Maximum 255 
     * characters (database VARCHAR(255)). This length accommodates various username formats 
     * including email addresses.</p>
     * 
     * <p><strong>Rationale for Existence (User Story Mapping):</strong></p>
     * <ul>
     * <li><strong>US-02 (Edit Ownership Check):</strong> Critical for permission enforcement. 
     *     Before allowing edits, ControllerPosts.performEditPost() compares this author field 
     *     with the current user's username:
     *     <pre>
     *     Post post = database.getPost(selectedId);
     *     if (!post.getAuthor().equals(currentUser.getUserName())) {
     *         // Show error: "You can only edit your own posts"
     *         return;
     *     }
     *     </pre>
     *     This prevents unauthorized editing of others' content.</li>
     * 
     * <li><strong>US-03 (Delete Ownership Check):</strong> Same permission logic as edit. 
     *     ControllerPosts.performDeletePost() verifies ownership before deletion. Prevents 
     *     students from deleting each other's posts (as noted in your User Stories document).</li>
     * 
     * <li><strong>US-04 (Display Attribution):</strong> Shown in ListView so students know 
     *     who posted each discussion item. Example display format:
     *     <code>"id: 5 author: john_doe [Role1] content: Great question about recursion!"</code>
     *     This provides context about who is contributing to discussions.</li>
     * 
     * <li><strong>TP3 Staff Analytics (Future):</strong> Enables instructors to:
     *     <ul>
     *         <li>Filter posts by specific students: "Show all posts by john_doe"</li>
     *         <li>Assess individual participation: "john_doe created 12 posts this week"</li>
     *         <li>Generate participation reports: "Students with fewer than 3 posts"</li>
     *         <li>Track engagement over time: "john_doe's posting frequency trends"</li>
     *     </ul>
     * </li>
     * </ul>
     * 
     * <p><strong>Security Considerations:</strong></p>
     * <ul>
     * <li>This field is <strong>immutable after creation</strong> (no setter provided for 
     *     author) to prevent users from claiming ownership of others' posts.</li>
     * <li>Always validated against User table to ensure author exists.</li>
     * <li>Case-sensitive comparison for permission checks (usernames are case-sensitive).</li>
     * </ul>
     * 
     * <p><strong>Data Integrity:</strong> Foreign key relationship with User.userName ensures 
     * referential integrity. If a user is deleted, database should handle cascading or prevent 
     * deletion if posts exist (implementation-dependent).</p>
     */
    private String author;
    
    /**
     * Text content of the discussion post. Limited to 500 characters.
     * 
     * <p><strong>Source:</strong> User input from ViewPosts.text_PostContent (TextArea GUI 
     * component). Retrieved via ViewPosts.text_PostContent.getText() in 
     * ControllerPosts.performSubmitPost().</p>
     * 
     * <p><strong>Data Type Rationale:</strong> String with VARCHAR(500) database constraint. 
     * 500-character limit chosen to:</p>
     * <ul>
     * <li>Prevent database overflow and excessive memory usage</li>
     * <li>Encourage concise, focused communication (similar to Ed Discussion design)</li>
     * <li>Ensure posts fit reasonably in GUI ListView without excessive scrolling</li>
     * <li>Balance between expressiveness and brevity in academic discussions</li>
     * </ul>
     * 
     * <p><strong>Rationale for Existence (User Story Mapping):</strong></p>
     * <ul>
     * <li><strong>US-01 (Create Posts):</strong> This is the CORE of the post - the actual 
     *     discussion content students want to share. Examples:
     *     <ul>
     *         <li>Questions: "How does recursion work in the factorial example from class?"</li>
     *         <li>Answers: "Recursion breaks the problem into smaller subproblems..."</li>
     *         <li>Explanations: "Here's another way to think about inheritance..."</li>
     *         <li>Collaborative Ideas: "What if we implemented the algorithm using..."</li>
     *     </ul>
     *     Without content, a post serves no purpose - this is the information being shared.</li>
     * 
     * <li><strong>US-02 (Edit Posts):</strong> This is the ONLY field users can modify after 
     *     creation. Allows students to:
     *     <ul>
     *         <li>Fix typos or grammatical errors</li>
     *         <li>Clarify unclear statements</li>
     *         <li>Add additional information or context</li>
     *         <li>Correct technical inaccuracies</li>
     *     </ul>
     *     Database.updatePost() ONLY modifies this field, not author or role.</li>
     * 
     * <li><strong>US-04 (View Posts):</strong> Primary information displayed to readers in the 
     *     ListView. Formatted by ModelPosts.formatPostForDisplay() as:
     *     <code>"id: X author: Name [Role] content: [This Content Here]"</code></li>
     * 
     * <li><strong>US-05 (Reply Context):</strong> When viewing replies, this content is 
     *     displayed read-only in ViewPosts.text_PostInReply so users can see what they're 
     *     replying to. Provides context for the discussion thread.</li>
     * </ul>
     * 
     * <p><strong>Validation Rules (Implemented in ControllerPosts):</strong></p>
     * <ul>
     * <li><strong>Not Empty:</strong> <code>if(content.equals("")) { ... }</code> prevents 
     *     submission of blank posts</li>
     * <li><strong>Length Check:</strong> Should verify content.length() <= 500 before database 
     *     submission (prevents database errors)</li>
     * <li><strong>Whitespace Trimming:</strong> Consider trimming leading/trailing spaces before 
     *     storage</li>
     * </ul>
     * 
     * <p><strong>Future Enhancements:</strong></p>
     * <ul>
     * <li>Search functionality: Database.searchPosts() would search this field for keywords</li>
     * <li>Profanity filter: Could add validation layer to check content before storage</li>
     * <li>Rich text: Could extend to support basic formatting (bold, italic, code blocks)</li>
     * </ul>
     */
    private String content;
    
    /**
     * Role of the author at the time this post was created (Admin, Role1, or Role2).
     * 
     * <p><strong>Source:</strong> Detected from User object's role flags via conditional logic 
     * in ControllerPosts.performSubmitPost():</p>
     * <pre>
     * String role = "Unknown";  // Default fallback
     * if (ViewPosts.theUser.getAdminRole()) {
     *     role = "Admin";
     * } else if (ViewPosts.theUser.getNewRole1()) {
     *     role = "Role1";
     * } else if (ViewPosts.theUser.getNewRole2()) {
     *     role = "Role2";
     * }
     * </pre>
     * 
     * <p><strong>Data Type Rationale:</strong> String rather than enum for flexibility. 
     * VARCHAR(10) in database. String choice allows easy addition of new roles (TA, Guest, 
     * Alumni) without schema changes or enum modifications.</p>
     * 
     * <p><strong>Valid Values:</strong></p>
     * <ul>
     * <li><code>"Admin"</code> - Instructional team members with full system privileges</li>
     * <li><code>"Role1"</code> - First student role group</li>
     * <li><code>"Role2"</code> - Second student role group</li>
     * <li><code>"Unknown"</code> - Fallback for legacy posts or role detection failures</li>
     * <li><code>null</code> - Possible for posts created before role tracking was implemented</li>
     * </ul>
     * 
     * <p><strong>Rationale for Existence (User Story Mapping):</strong></p>
     * <ul>
     * <li><strong>US-04 (Display Context):</strong> Shows role badge in post listings for quick 
     *     visual identification. ModelPosts.formatPostForDisplay() formats as:
     *     <code>"id: 5 author: prof_smith [Admin] content: Assignment deadline extended"</code>
     *     
     *     <p>This helps students immediately understand post context:</p>
     *     <ul>
     *         <li><strong>[Admin]</strong> posts are official announcements from instructors</li>
     *         <li><strong>[Role1]</strong> posts are from Role1 student group</li>
     *         <li><strong>[Role2]</strong> posts are from Role2 student group</li>
     *     </ul>
     *     
     *     <p>Benefits student comprehension and trust in information sources.</p>
     * </li>
     * 
     * <li><strong>TP3 Staff Analytics (Critical for Future Requirements):</strong> While not 
     *     explicitly required by current Student User Stories, this attribute is ESSENTIAL for 
     *     Staff User Stories (TP3) where instructors need to:
     *     
     *     <p><strong>Filter Operations:</strong></p>
     *     <ul>
     *         <li>"Show only Role1 posts" - Assess Role1 group participation</li>
     *         <li>"Show only Role2 posts" - Assess Role2 group participation</li>
     *         <li>"Show only Admin posts" - Review official announcements</li>
     *     </ul>
     *     
     *     <p><strong>Analytics Reports:</strong></p>
     *     <ul>
     *         <li>"Role1 students posted 30% less than Role2 this week"</li>
     *         <li>"Compare discussion quality between Role1 and Role2"</li>
     *         <li>"Which role is most active in discussions?"</li>
     *         <li>"Identify students in Role2 with low participation"</li>
     *     </ul>
     *     
     *     <p><strong>Grading Support:</strong></p>
     *     <ul>
     *         <li>Assess role-based participation for group grading</li>
     *         <li>Generate participation reports by role</li>
     *         <li>Track engagement patterns across different student groups</li>
     *     </ul>
     * </li>
     * </ul>
     * 
     * <p><strong>Design Decision - Historical Accuracy:</strong></p>
     * <p>This field captures the author's role <strong>at time of posting</strong>, not their 
     * current role. Example scenario:</p>
     * <pre>
     * 1. Student John is in Role1 on Monday
     * 2. John creates a post → authorRole = "Role1"
     * 3. Admin changes John to Role2 on Tuesday
     * 4. John's Monday post STILL shows [Role1] badge
     * </pre>
     * 
     * <p><strong>Rationale:</strong> Provides accurate historical context. If posts showed 
     * current role instead of original role, past discussions would be confusing and analytics 
     * would be inaccurate.</p>
     * 
     * <p><strong>Null Handling:</strong> Can be null for posts created before role tracking 
     * was implemented (legacy data). Display code should check for null and default to 
     * "Unknown" badge:</p>
     * <pre>
     * String displayRole = (post.getAuthorRole() != null) ? 
     *                      post.getAuthorRole() : "Unknown";
     * </pre>
     * 
     * <p><strong>Display Format:</strong> ModelPosts.formatPostForDisplay() wraps role in 
     * brackets for visual distinction: <code>[Role]</code></p>
     */
    private String authorRole;
    
    // ==================== CONSTRUCTOR ====================
    
    /**
     * Constructs a Post object with all required attributes.
     * 
     * <p><strong>Usage Context:</strong> This constructor is primarily called when reading posts 
     * from the database. The database query returns a ResultSet containing post data, and each 
     * row is converted into a Post object using this constructor.</p>
     * 
     * <p><strong>Typical Usage Pattern:</strong></p>
     * <pre>
     * // In Database.getPost(int postID):
     * String query = "SELECT * FROM Post WHERE id = ?";
     * PreparedStatement pstmt = connection.prepareStatement(query);
     * pstmt.setInt(1, postID);
     * ResultSet rs = pstmt.executeQuery();
     * 
     * if (rs.next()) {
     *     return new Post(
     *         rs.getInt("id"),           // Database-generated ID
     *         rs.getString("author"),     // Username from Post table
     *         rs.getString("content"),    // Post text from Post table
     *         rs.getString("authorRole")  // Role from Post table (may be null)
     *     );
     * }
     * </pre>
     * 
     * <p><strong>Parameter Order Rationale:</strong> Matches database column order (id, author, 
     * content, authorRole) for consistency, readability, and reducing errors when extracting 
     * from ResultSet.</p>
     * 
     * <p><strong>No Validation:</strong> This constructor performs NO validation because it 
     * assumes data from database is already valid (enforced by database constraints). 
     * Validation occurs at creation time in ControllerPosts.performSubmitPost() before 
     * database insertion.</p>
     * 
     * <p><strong>Not Used for New Posts:</strong> When creating new posts, the ID doesn't exist 
     * yet (auto-generated by database). In that case, Database.createPost() passes parameters 
     * directly to INSERT statement rather than using this constructor.</p>
     * 
     * @param id the unique post identifier (positive integer, auto-generated by database 
     *           AUTO_INCREMENT). Must be greater than 0. Represents the permanent identity 
     *           of this post in the system.
     * 
     * @param author the username of post creator (from User table, non-null, max 255 chars).
     *               Must be a valid username that exists in the User table. This establishes
     *               ownership for permission checks (edit/delete operations).
     * 
     * @param content the post text content (user input, 1-500 characters, non-null). This is
     *                the actual discussion content - question, answer, explanation, or idea
     *                being shared by the student.
     * 
     * @param authorRole the role label (Admin/Role1/Role2, max 10 chars, nullable). Captures
     *                   the author's role at time of posting for display badges and future
     *                   staff analytics. May be null for legacy posts created before role
     *                   tracking was implemented.
     * 
     * @see database.Database#getPost(int)
     * @see database.Database#getAllPosts()
     * @see database.Database#getPostsByAuthor(String)
     */
    public Post(int id, String author, String content, String authorRole) {
        this.id = id;
        this.author = author;
        this.content = content;
        this.authorRole = authorRole;
    }
    
    // ==================== GETTERS ====================
    
    /**
     * Returns the unique identifier of this post.
     * 
     * <p><strong>Usage Scenarios:</strong></p>
     * <ul>
     * <li><strong>US-02 (Edit Posts):</strong> 
     *     ControllerPosts.performEditPost() extracts ID from selected ListView item using
     *     ModelPosts.getID(), then passes ID to Database.updatePost(id, newContent) to 
     *     update the correct post.</li>
     * 
     * <li><strong>US-03 (Delete Posts):</strong> 
     *     ControllerPosts.performDeletePost() extracts ID from selection, then calls 
     *     Database.deletePost(id) to remove the correct post.</li>
     * 
     * <li><strong>US-05 (Replies):</strong> 
     *     When viewing replies, ViewPosts stores currentPostID = post.getPostID() to track 
     *     which post the user is viewing. When creating a reply, Reply.postId is set to this
     *     value to establish the parent-child relationship.</li>
     * 
     * <li><strong>Display Formatting:</strong> 
     *     ModelPosts.formatPostForDisplay() includes ID in output for clarity:
     *     <code>"id: 5 author: john [Role1] content: Great question!"</code>
     *     This helps users identify specific posts when referring to them in discussions.</li>
     * 
     * <li><strong>Foreign Key Relationships:</strong>
     *     Database.getRepliesForPost(postID) uses this ID to query all replies where 
     *     Reply.postId matches this Post.id</li>
     * </ul>
     * 
     * @return the post's unique identifier (positive integer, always greater than 0). This
     *         is the permanent ID assigned by the database when the post was created.
     * 
     * @see database.Database#updatePost(int, String)
     * @see database.Database#deletePost(int)
     * @see database.Database#getRepliesForPost(int)
     */
    public int getPostID() {
        return this.id;
    }
    
    /**
     * Returns the username of the person who created this post.
     * 
     * <p><strong>Usage Scenarios:</strong></p>
     * <ul>
     * <li><strong>US-02/US-03 Permission Checks:</strong> Critical for enforcing ownership.
     *     Example from ControllerPosts.performEditPost():
     *     <pre>
     *     Post post = database.getPost(selectedId);
     *     String postAuthor = post.getAuthor();
     *     String currentUser = ViewPosts.theUser.getUserName();
     *     
     *     if (!postAuthor.equals(currentUser)) {
     *         // Show error dialog
     *         Alert alert = new Alert(Alert.AlertType.ERROR);
     *         alert.setTitle("Permission Denied");
     *         alert.setHeaderText("Cannot Edit Post");
     *         alert.setContentText("You can only edit your own posts.");
     *         alert.showAndWait();
     *         return; // Block the edit operation
     *     }
     *     // If we reach here, user owns the post - allow edit
     *     </pre>
     *     Same logic applies to delete operations. This prevents the problem described in 
     *     your User Stories: "Students keep removing each other's posts and replies".</li>
     * 
     * <li><strong>US-04 Display:</strong> Shows who posted in GUI for attribution and context.
     *     Example: <code>"id: 5 author: john_doe [Role1] content: ..."</code></li>
     * 
     * <li><strong>TP3 Analytics (Future):</strong> Instructors can:
     *     <ul>
     *         <li>Filter posts: "Show all posts by john_doe"</li>
     *         <li>Generate reports: "john_doe created 12 posts this week"</li>
     *         <li>Identify low-participation students: "Students with fewer than 3 posts"</li>
     *         <li>Track engagement trends: "john_doe's posting frequency over time"</li>
     *     </ul>
     * </li>
     * </ul>
     * 
     * <p><strong>Data Integrity:</strong> This username MUST exist in the User table (foreign
     * key relationship). Database should enforce referential integrity to prevent orphaned posts.</p>
     * 
     * <p><strong>Case Sensitivity:</strong> Username comparisons are case-sensitive. "JohnDoe" 
     * and "johndoe" are different users.</p>
     * 
     * @return the post author's username (never null, 1-255 characters). This is the username
     *         from the User table that identifies who created the post.
     * 
     * @see entityClasses.User
     * @see database.Database#getPostsByAuthor(String)
     */
    public String getAuthor() {
        return this.author;
    }
    
    /**
     * Returns the text content of this post.
     * 
     * <p><strong>Usage Scenarios:</strong></p>
     * <ul>
     * <li><strong>US-04 (View Posts):</strong> Primary content displayed to readers in the 
     *     ListView. ModelPosts.formatPostForDisplay() extracts this content and includes it 
     *     in the formatted display string:
     *     <code>"id: 5 author: john [Role1] content: [This Content Here]"</code></li>
     * 
     * <li><strong>US-05 (Reply Context):</strong> When viewing replies, this content is shown 
     *     read-only in ViewPosts.text_PostInReply TextArea so users can see what they're 
     *     replying to. Example:
     *     <pre>
     *     Post selectedPost = database.getPost(selectedId);
     *     ViewPosts.text_PostInReply.setText(selectedPost.getContent());
     *     ViewPosts.text_PostInReply.setEditable(false); // Read-only
     *     </pre>
     *     This provides context for the discussion thread.</li>
     * 
     * <li><strong>US-02 (Pre-fill Edit Dialog):</strong> When editing a post, the current 
     *     content is retrieved and shown in the edit dialog so users can modify it:
     *     <pre>
     *     Post post = database.getPost(selectedId);
     *     String currentContent = post.getContent();
     *     // Show dialog with currentContent pre-filled
     *     TextInputDialog dialog = new TextInputDialog(currentContent);
     *     </pre>
     * </li>
     * 
     * <li><strong>Search Functionality (Future):</strong> Database.searchPosts(keyword) would 
     *     search this field for matching keywords to help students find relevant discussions.</li>
     * </ul>
     * 
     * <p><strong>Content Characteristics:</strong></p>
     * <ul>
     * <li>Length: 1-500 characters (enforced by database VARCHAR(500))</li>
     * <li>Never null (database constraint: NOT NULL)</li>
     * <li>May contain any text including punctuation, numbers, Unicode characters</li>
     * <li>Newlines preserved if present in original input</li>
     * </ul>
     * 
     * @return the post's text content (1-500 characters, never null). This is the actual
     *         discussion content - the question, answer, explanation, or idea the student
     *         is sharing with classmates.
     * 
     * @see guiPosts.ModelPosts#formatPostForDisplay(Post)
     */
    public String getContent() {
        return this.content;
    }
    
    /**
     * Returns the role of the author when they created this post.
     * 
     * <p><strong>Usage Scenarios:</strong></p>
     * <ul>
     * <li><strong>US-04 (Display Role Badges):</strong> ModelPosts.formatPostForDisplay() uses 
     *     this to show role badges in the post listing:
     *     <pre>
     *     String role = post.getAuthorRole();
     *     if (role == null) role = "Unknown"; // Handle legacy posts
     *     String badge = "[" + role + "]";
     *     String display = "id: " + post.getPostID() + " author: " + 
     *                      post.getAuthor() + " " + badge + " content: " + 
     *                      post.getContent();
     *     </pre>
     *     Results in: <code>"id: 5 author: prof_smith [Admin] content: Deadline extended"</code>
     *     
     *     <p><strong>Why This Matters to Students:</strong></p>
     *     <ul>
     *         <li><strong>[Admin]</strong> badge indicates official announcements - high trust</li>
     *         <li><strong>[Role1]/[Role2]</strong> badges show peer contributions - collaborative</li>
     *         <li>Quick visual identification without reading full post</li>
     *         <li>Helps students prioritize which posts to read first</li>
     *     </ul>
     * </li>
     * 
     * <li><strong>TP3 Staff Analytics (Future):</strong> Critical for instructor features:
     *     <p><strong>Filtering Operations:</strong></p>
     *     <pre>
     *     // Get all Role1 posts for assessment
     *     List&lt;Post&gt; role1Posts = database.getAllPosts().stream()
     *         .filter(p -> "Role1".equals(p.getAuthorRole()))
     *         .collect(Collectors.toList());
     *     
     *     // Get all Role2 posts
     *     List&lt;Post&gt; role2Posts = database.getAllPosts().stream()
     *         .filter(p -> "Role2".equals(p.getAuthorRole()))
     *         .collect(Collectors.toList());
     *     </pre>
     *     
     *     <p><strong>Analytics Examples:</strong></p>
     *     <ul>
     *         <li>"Role1 group created 45 posts this week"</li>
     *         <li>"Role2 group created 32 posts this week"</li>
     *         <li>"Role1 participation is 40% higher than Role2"</li>
     *         <li>"Generate engagement report by role"</li>
     *     </ul>
     * </li>
     * </ul>
     * 
     * <p><strong>Null Handling:</strong> Can be null for posts created before role tracking 
     * was implemented (legacy data from earlier versions). Display code MUST check for null:
     * <pre>
     * String displayRole = (post.getAuthorRole() != null) ? 
     *                      post.getAuthorRole() : "Unknown";
     * </pre>
     * Failing to check for null will cause NullPointerException in GUI display code.</p>
     * 
     * <p><strong>Historical Immutability:</strong> This field captures the author's role at 
     * time of posting, NOT their current role. If a user's role changes after posting, their 
     * old posts retain the original role badge. This provides accurate historical context.</p>
     * 
     * @return the author's role (Admin, Role1, Role2, or null for legacy posts). Null indicates
     *         the post was created before role tracking was implemented. Display code should
     *         default to "Unknown" when null.
     * 
     * @see guiPosts.ModelPosts#formatPostForDisplay(Post)
     */
    public String getAuthorRole() {
        return this.authorRole;
    }
    
    // ==================== SETTERS ====================
    
    /**
     * Sets the post's unique identifier.
     * 
     * <p><strong>⚠️ WARNING - USE WITH EXTREME CAUTION:</strong> This setter should RARELY be 
     * used in normal application flow. The ID is typically set only once by the database during 
     * post creation via AUTO_INCREMENT. Changing IDs after creation can cause severe data 
     * integrity issues.</p>
     * 
     * <p><strong>Dangers of Changing Post IDs:</strong></p>
     * <ul>
     * <li><strong>Broken Foreign Keys:</strong> Replies link to posts via Reply.postId. If you 
     *     change a post's ID, replies will point to the wrong post or to a non-existent post:
     *     <pre>
     *     Original: Post ID=5 has 3 replies (Reply.postId = 5)
     *     Change Post.id to 10
     *     Result: Those 3 replies now point to wrong post (or nothing)
     *     </pre>
     * </li>
     * <li><strong>ListView Confusion:</strong> GUI displays use IDs for selection. Changing IDs 
     *     mid-session causes selected post to become different post.</li>
     * <li><strong>Database Conflicts:</strong> Auto-increment might generate an ID you manually 
     *     set, causing primary key conflicts.</li>
     * </ul>
     * 
     * <p><strong>Valid Use Cases (Very Rare):</strong></p>
     * <ul>
     * <li><strong>Data Migration:</strong> Importing posts from another system where you need 
     *     to preserve original IDs for compatibility.</li>
     * <li><strong>Database Seeding:</strong> Creating test data with specific IDs for testing 
     *     purposes (development/testing environments only).</li>
     * <li><strong>Manual Correction:</strong> Fixing database corruption (should be done via 
     *     SQL, not application code).</li>
     * </ul>
     * 
     * <p><strong>Best Practice:</strong> In normal operation, NEVER call this method. Let the 
     * database AUTO_INCREMENT handle ID assignment. If you think you need to change a post ID, 
     * you probably need to delete the old post and create a new one instead.</p>
     * 
     * @param id the new post identifier (must be unique, positive integer greater than 0).
     *           MUST NOT conflict with existing post IDs in database. MUST NOT be an ID that
     *           AUTO_INCREMENT might generate in the future.
     */
    public void setPostId(int id) {
        this.id = id;
    }
    
    /**
     * Updates the content of this post.
     * 
     * <p><strong>Implements: US-02 (Edit Posts)</strong></p>
     * 
     * <p><strong>This is the ONLY editable field after post creation.</strong> Users cannot 
     * change the author, ID, or role - only the content can be modified. This design ensures:</p>
     * <ul>
     * <li>Ownership cannot be transferred (author is immutable)</li>
     * <li>Post identity remains stable (ID is immutable)</li>
     * <li>Historical accuracy preserved (role at time of posting is immutable)</li>
     * </ul>
     * 
     * <p><strong>Usage Example in Database.updatePost():</strong></p>
     * <pre>
     * public void updatePost(int postID, String newContent) throws SQLException {
     *     // US-02 Implementation: Update ONLY the content field
     *     String updateSQL = "UPDATE Post SET content = ? WHERE id = ?";
     *     
     *     try (PreparedStatement pstmt = connection.prepareStatement(updateSQL)) {
     *         pstmt.setString(1, newContent);  // New content (this setter's parameter)
     *         pstmt.setInt(2, postID);         // Which post to update
     *         
     *         int rowsAffected = pstmt.executeUpdate();
     *         if (rowsAffected == 0) {
     *             throw new SQLException("Post not found: " + postID);
     *         }
     *     }
     * }
     * </pre>
     * 
     * <p><strong>Security Flow in ControllerPosts.performEditPost():</strong></p>
     * <pre>
     * 1. User selects post in ListView
     * 2. Clicks "Edit Post" button
     * 3. Controller retrieves post: Post post = database.getPost(selectedId)
     * 4. SECURITY CHECK: Verify ownership
     *    if (!post.getAuthor().equals(currentUser)) {
     *        show error dialog; return;
     *    }
     * 5. Show edit dialog with current content pre-filled
     * 6. User modifies content and clicks OK
     * 7. Controller calls: database.updatePost(postId, newContent)
     * 8. Database calls: post.setContent(newContent)  ← THIS METHOD
     * 9. Content updated in memory and persisted to database
     * </pre>
     * 
     * <p><strong>Validation Requirements:</strong></p>
     * <p>This setter performs NO validation - validation must happen BEFORE calling this method.
     * ControllerPosts.performEditPost() is responsible for validating:</p>
     * <ul>
     * <li><strong>Not Empty:</strong> Content cannot be blank string
     *     <pre>if (newContent.trim().isEmpty()) { show error; return; }</pre>
     * </li>
     * <li><strong>Length Limit:</strong> Content must be 500 characters or fewer
     *     <pre>if (newContent.length() > 500) { show error; return; }</pre>
     * </li>
     * <li><strong>Not Null:</strong> Content cannot be null
     *     <pre>if (newContent == null) { show error; return; }</pre>
     * </li>
     * </ul>
     * 
     * <p><strong>Why Students Edit Posts (US-02 Rationale):</strong></p>
     * <ul>
     * <li>Fix typos or grammatical errors</li>
     * <li>Clarify unclear or ambiguous statements</li>
     * <li>Add additional context or information</li>
     * <li>Correct technical inaccuracies</li>
     * <li>Update with new insights after further research</li>
     * </ul>
     * 
     * <p><strong>What Cannot Be Changed:</strong></p>
     * <ul>
     * <li>Author (ownership is permanent)</li>
     * <li>Post ID (identity is permanent)</li>
     * <li>Author Role (historical accuracy preserved)</li>
     * </ul>
     * 
     * @param content the new post content (1-500 characters, non-empty, non-null). This replaces
     *                the existing content entirely. Validation must be performed by the caller
     *                before invoking this method.
     * 
     * @see database.Database#updatePost(int, String)
     * @see guiPosts.ControllerPosts#performEditPost()
     */
    public void setContent(String content) {
        this.content = content;
    }
    
    /**
     * Sets the author's role for this post.
     * 
     * <p><strong>Usage Context:</strong> This setter is primarily used in two scenarios:</p>
     * <ol>
     * <li><strong>Initial Post Creation:</strong> When creating a new Post object before saving 
     *     to database, the role is determined and set by ControllerPosts.performSubmitPost().
     * </li>
     * <li><strong>Database Migration:</strong> When updating legacy posts (created before role 
     *     tracking) to add role information retroactively.
     * </li>
     * </ol>
     * 
     * <p><strong>Example Usage Pattern:</strong></p>
     * <pre>
     * // In ControllerPosts.performSubmitPost()
     * String author = ViewPosts.theUser.getUserName();
     * String content = ViewPosts.text_PostContent.getText();
     * 
     * // Determine role based on user's current roles
     * String role = "Unknown";
     * if (ViewPosts.theUser.getAdminRole()) {
     *     role = "Admin";
     * } else if (ViewPosts.theUser.getNewRole1()) {
     *     role = "Role1";
     * } else if (ViewPosts.theUser.getNewRole2()) {
     *     role = "Role2";
     * }
     * 
     * // Create and save post with detected role
     * database.createPost(author, content, role);  ← Role passed to INSERT
     * </pre>
     * 
     * <p><strong>⚠️ Immutability Principle:</strong> Once a post is created with a role, that 
     * role should NOT be changed under normal circumstances. The role represents the author's 
     * role <strong>at time of posting</strong>, providing accurate historical context even if 
     * their current role changes later.</p>
     * 
     * <p><strong>Why Historical Immutability Matters:</strong></p>
     * <pre>
     * Scenario: Student John posted as Role1 on Monday
     * Monday: John creates post → authorRole = "Role1" → Post shows [Role1]
     * Tuesday: Admin changes John's role to Role2
     * 
     * CORRECT BEHAVIOR (Immutable):
     * - Monday's post STILL shows [Role1] badge
     * - Provides accurate historical context
     * - Analytics correctly count it as Role1 participation
     * 
     * INCORRECT BEHAVIOR (If we changed authorRole):
     * - Monday's post NOW shows [Role2] badge
     * - Historical record is inaccurate
     * - Analytics are wrong (post wasn't created by Role2)
     * - Confusing for students reading old discussions
     * </pre>
     * 
     * <p><strong>When This Setter Should Be Called:</strong></p>
     * <ul>
     * <li><strong>Post Creation (Normal Use):</strong> Set role once when post is created, 
     *     never change it again.</li>
     * <li><strong>Data Migration (Rare):</strong> Adding roles to legacy posts that have null 
     *     authorRole. Must determine original role from User records at time of posting.</li>
     * <li><strong>Database Seeding (Testing):</strong> Creating test posts with specific roles 
     *     for testing purposes.</li>
     * </ul>
     * 
     * <p><strong>When This Setter Should NOT Be Called:</strong></p>
     * <ul>
     * <li>When user's current role changes (post should retain original role)</li>
     * <li>When "correcting" a role badge (if wrong, post was created with wrong data - don't 
     *     change history)</li>
     * <li>In any edit operation (US-02 only allows editing content, not role)</li>
     * </ul>
     * 
     * <p><strong>Null Handling:</strong> Setting role to null is valid for legacy posts, but 
     * should be avoided for new posts. Display code will show [Unknown] badge for null roles.</p>
     * 
     * @param authorRole the role to assign (Admin, Role1, Role2, or null). Should only be set
     *                   once during post creation. Do NOT change this field after creation
     *                   unless performing data migration for legacy posts.
     */
    public void setAuthorRole(String authorRole) {
        this.authorRole = authorRole;
    }
    
    // ==================== UTILITY METHODS ====================
    
    /**
     * Returns a string representation of this Post for debugging purposes.
     * 
     * <p><strong>Purpose:</strong> Primarily for console debugging during development. This 
     * method is NOT used for GUI display - see ModelPosts.formatPostForDisplay() for that.</p>
     * 
     * <p><strong>Use Cases:</strong></p>
     * <ul>
     * <li><strong>Console Debugging:</strong>
     *     <pre>
     *     Post post = database.getPost(5);
     *     System.out.println("DEBUG: Retrieved post: " + post);
     *     // Output: id: 5 author: john_doe role: Role1 content: Great question!
     *     </pre>
     * </li>
     * <li><strong>Logging:</strong> When logging post-related operations to console or log files
     *     for debugging and troubleshooting.</li>
     * <li><strong>Unit Testing:</strong> Verifying post attributes in test assertions.</li>
     * </ul>
     * 
     * <p><strong>Format Difference from GUI Display:</strong></p>
     * <pre>
     * toString():                "id: 5 author: john role: Role1 content: Great!"
     * GUI Display (ModelPosts):  "id: 5 author: john [Role1] content: Great!"
     *                                                  ↑↑↑↑↑↑↑ Brackets for visual clarity
     * </pre>
     * 
     * <p><strong>Why Not Use This for GUI?</strong></p>
     * <ul>
     * <li>toString() is for developers (debugging), not end users</li>
     * <li>GUI display needs formatted, user-friendly presentation</li>
     * <li>ModelPosts.formatPostForDisplay() provides proper formatting with brackets, 
     *     proper spacing, and truncation if needed</li>
     * </ul>
     * 
     * <p><strong>Example Output:</strong></p>
     * <pre>
     * id: 5 author: john_doe role: Role1 content: Great question about recursion!
     * id: 12 author: admin role: Admin content: Assignment deadline extended to Friday
     * id: 8 author: jane_smith role: Role2 content: Here's how I approached the problem...
     * </pre>
     * 
     * @return a formatted string showing all post attributes separated by spaces. Format:
     *         "id: [id] author: [author] role: [role] content: [content]"
     *         If role is null, displays "role: null"
     * 
     * @see guiPosts.ModelPosts#formatPostForDisplay(Post)
     */
    @Override
    public String toString() {
        return "id: " + id + " author: " + author + " role: " + authorRole + 
               " content: " + content;
    }
}